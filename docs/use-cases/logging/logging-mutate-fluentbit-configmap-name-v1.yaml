# logging-mutate-fluentbit-configmap-name-v1 is a policy that adds the name of the fluentbit configmap for the pods created by
# deployments, daemonsets, statefulsets and cronjobs which have the label admitik.policy.v1/logging set to true and the annotation
# admitik.policy.v1/loggingConfig set to a valid yaml configuration.

# This policy adds the name of the configmap to the annotations of the child object.
# If the admitik.policy.v1/loggingSidecarResources annotation is present, it will be propagated as admitik.policy.v1/fluentbitResources to the pod template.

apiVersion: admitik.dev/v1alpha1
kind: ClusterMutationPolicy
metadata:
  name: logging-mutate-fluentbit-configmap-name-v1
spec:

  # Resources to be intercepted before reaching the cluster
  interceptedResources:
    - group: apps
      version: v1
      resource: deployments
      operations:
        - CREATE
        - UPDATE
    - group: apps
      version: v1
      resource: daemonsets
      operations:
        - CREATE
        - UPDATE
    - group: apps
      version: v1
      resource: statefulsets
      operations:
        - CREATE
        - UPDATE
    - group: argoproj.io
      version: v1alpha1
      resource: rollouts
      operations:
        - CREATE
        - UPDATE

  # Other resources to be retrieved for conditions templates.
  # They will be included under .sources scope in the template
  sources: []

  # Conditions are optional, so no-conditions means they are always met
  conditions:
    - name: apply-on-specific-mark
      engine: cel
      key: |              
        (has(object.metadata.labels) &&
        object.metadata.labels.exists(label, label == 'admitik.policy.v1/logging')) ||
        
        (has(object.metadata.annotations) &&
        object.metadata.annotations.exists(label, label == 'admitik.policy.v1/logging'))

      value: "true"

  patch:
    type: jsonpatch # JsonPatch | JsonMerge
    engine: starlark
    template: |
      def check_operation():
        patch = []
      
        if "annotations" not in object["spec"]["template"]["metadata"]:
          patch = patch + [{"op": "add", "path": "/spec/template/metadata/annotations", "value": {}}]
      
        patch = patch + [
          {"op": "add", "path": "/spec/template/metadata/annotations/admitik.policy.v1~1fluentbitConfigmap", "value": "fluentbit-" + object["metadata"]["name"] + "-autogenerated" },
          {"op": "add", "path": "/spec/template/metadata/annotations/admitik.policy.v1~1fluentbitConfigmapHash", "value": hashlib.sha256(object["metadata"]["annotations"]["admitik.policy.v1/loggingConfig"]) },
          {"op": "add", "path": "/spec/template/metadata/labels/admitik.policy.v1~1logging", "value": "true" }
        ]

        # Add fluentbitResources annotation if loggingSidecarResources is present
        if object["metadata"].get("annotations", {}).get("admitik.policy.v1/loggingSidecarResources"):
          entry = yaml.decode(object["metadata"]["annotations"]["admitik.policy.v1/loggingSidecarResources"])
          if entry.get("requests"):
              cpuRequest = entry.get("requests").get("cpu", "50m")
              memoryRequest = entry.get("requests").get("memory", "50Mi")
          else:
              cpuRequest = "50m"
              memoryRequest = "50Mi"
          if entry.get("limits"):
              memoryLimit = entry.get("limits").get("memory", "100Mi")
          else:
              memoryLimit = "100Mi"
          resources = {
              "requests": {
                  "cpu": cpuRequest,
                  "memory": memoryRequest
              },
              "limits": {
                  "memory": memoryLimit
              }
          }
          patch = patch + [
            {"op": "add", "path": "/spec/template/metadata/annotations/admitik.policy.v1~1fluentbitResources", "value": json.encode(resources) }
          ]

        print(json.encode(patch))
    
      check_operation()

---

# For cronjobs, we need to mutate the jobTemplate.spec.template.metadata.annotations and labels instead of the spec.template.metadata.annotations and labels
apiVersion: admitik.freepik.com/v1alpha1
kind: ClusterMutationPolicy
metadata:
  name: logging-mutate-fluentbit-cronjob-configmap-name-v1
spec:

  # Resources to be intercepted before reaching the cluster
  interceptedResources:
    - group: batch
      version: v1
      resource: cronjobs
      operations:
        - CREATE
        - UPDATE

  # Other resources to be retrieved for conditions templates.
  # They will be included under .sources scope in the template
  sources: []

  # Conditions are optional, so no-conditions means they are always met
  conditions:
    - name: apply-on-specific-mark
      engine: cel
      key: |              
        (has(object.metadata.labels) &&
        object.metadata.labels.exists(label, label == 'admitik.policy.v1/logging')) ||
        
        (has(object.metadata.annotations) &&
        object.metadata.annotations.exists(label, label == 'admitik.policy.v1/logging'))

      value: "true"

  patch:
    type: jsonpatch # JsonPatch | StrategicMerge
    engine: starlark
    template: |
      def check_operation():
        patch = []
      
        if "annotations" not in object["spec"]["jobTemplate"]["spec"]["template"]["metadata"]:
          patch = patch + [{"op": "add", "path": "/spec/jobTemplate/spec/template/metadata/annotations", "value": {}}]
      
        patch = patch + [
          {"op": "add", "path": "/spec/jobTemplate/spec/template/metadata/annotations/admitik.policy.v1~1fluentbitConfigmap", "value": "fluentbit-" + object["metadata"]["name"] + "-autogenerated" },
          {"op": "add", "path": "/spec/jobTemplate/spec/template/metadata/labels/admitik.policy.v1~1logging", "value": "true" }
        ]

        # Add fluentbitResources annotation if loggingSidecarResources is present
        if object["metadata"].get("annotations", {}).get("admitik.policy.v1/loggingSidecarResources"):
          entry = yaml.decode(object["metadata"]["annotations"]["admitik.policy.v1/loggingSidecarResources"])
          if entry.get("requests"):
              cpuRequest = entry.get("requests").get("cpu", "50m")
              memoryRequest = entry.get("requests").get("memory", "50Mi")
          else:
              cpuRequest = "50m"
              memoryRequest = "50Mi"
          if entry.get("limits"):
              memoryLimit = entry.get("limits").get("memory", "100Mi")
          else:
              memoryLimit = "100Mi"
          resources = {
              "requests": {
                  "cpu": cpuRequest,
                  "memory": memoryRequest
              },
              "limits": {
                  "memory": memoryLimit
              }
          }
          patch = patch + [
            {"op": "add", "path": "/spec/jobTemplate/spec/template/metadata/annotations/admitik.policy.v1~1fluentbitResources", "value": object["metadata"]["annotations"]["admitik.policy.v1/loggingSidecarResources"] }
          ]

        print(json.encode(patch))
    
      check_operation()